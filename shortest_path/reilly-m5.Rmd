---
title: "reilly-m5"
author: "Nolan Reilly"
date: "11/23/2020"
output: pdf_document
---
``` {r setup,include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(optrees)
library(igraph)
library(qgraph)
library(knitr)
```

# Matrix Representation of a Graph
* The below code will generate a random adjacency matrix. This function can scale efficiently to ~ 500 columns and rows on my machine:  
  
``` {r adjacency_matrix, warning = FALSE}
createAdjMatrix = function(n){               # n = number of columns and rows
  d = runif(n*n)                             # generate random data from 0-1
  d[d < .8] = NA                             # 20% chance of adjacency   
  d = matrix(d, nrow = n)                    # form data into a square matrix
  diag(d) = NA                               # make diagonal into NAs
  d[upper.tri(d)] = t(d)[upper.tri(d)]       # make upper & lower triangles adjacent
  return(d)                                     # i.e distance 1->3 is the same as 3->1
}
testmatrix = createAdjMatrix(5)
kable(testmatrix, digits = 2, caption = 'Adjacency Matrix')
```

* The next step in the workbook is to translate the above adjacency matrix into an adjacency list representation: 

```{r matrix_list}
AdjMatrix2List <- function(d){               # d = adjacency matrix, use above function 
  x = vector()                               # initialize empty vector to store results
  for (i in 1:nrow(d)){                      # loop through row
    for (j in 1:ncol(d)){                    # loop over each column value in row
      if(!is.na(d[i,j])){                    # skip over NAs/values without adjacency
        x = c(x, i, j, d[i,j])               # appending the row, column, & value 
      }
    }
  }
  labs = c('head', 'tail', 'weight')         # column names for results matrix
  ds = matrix(x, ncol = 3, byrow = TRUE)     # shape result vector into a 3 column matrix 
  colnames(x = ds) = labs                    # add column labels      
  return(ds)
}

#testmatrix = createAdjMatrix(100)            # create matrix with n rows/columns
kable(AdjMatrix2List(testmatrix), 
      digits = 2,
      caption = 'Adjacency List Representation')  
```

# Euclidean Minimum Spanning Tree
In this exercise, I will create a Euclidean Minimum Spanning  Tree (E-MST) on a set of random (X, Y) coordinates. One can think of each of these coordinates as locations for a facility where we want to build and visualize a road network that connects all of these facilities at minimum cost. 

* I will first create a set of 50 random X,Y coordinates to represent 50 facilities that we want to efficiently connect (minimum cost).
```{r xy_coord_gen}
n <- 50                                      # number of points to generate
x <- round(runif(n)*1000)
y <- round(runif(n)*1000)
plot(x,y,pch=16)
```
* The following code generates a complete graph of the  distances between all 50 facilities (generated above). This is a complete graph because it calculates the distance between every single facility - resulting in an adjacency matrix that is full, except for 0's along the diagonal (when a facility is paired with itself). 

```{r complete_graph}
hold = vector()                               # initialize empty vector to store results            

for (i in 1:n){                               # set point 1
  for (j in 1:n){                             # set point 2
    dist = sqrt(((y[j] - y[i])**2) +          # calculate euclidean distance
                  ((x[j] - x[i])**2))
    hold = c(hold, dist)                      # append distance to results vector
  }
}

matrixlabs = paste('(',x,',',y,')',sep ='')   # generate coordinate labels
holdresults = matrix(hold, ncol = n,          # shape results into square matrix
                     byrow = TRUE,
                     dimnames = list(matrixlabs,matrixlabs))

kable(head(holdresults[,1:5]), 
      digits = 2, caption = 'Complete Adjacency Matrix')
```

* I will now use the AdjMatrix2List function (created above) to transform this complete adjacency matrix into an adjacency list:

```{r complete_adj_list}

ds = AdjMatrix2List(holdresults)      
kable(head(ds), caption = 'Complete Adjacency List')
```

* This format now allows me to calculate the minimum spanning tree (the most efficient path between the facilities). This will be calculated using the Dijkstra-Prim algorithm that is found in the 'optrees' package.    

```{r minimum_Tree}
ds.mst = msTreePrim(nodes = 1:n,              # calculate minimum spanning tree 
                    arcs = ds)                # arcs = adjacency list created above
route = ds.mst$tree.arcs                      # pull the route (from-to) from results
head(route)                                   # ept1 = starting node | ept2 = ending node
```


* This information can be used to graphically represent the most efficient route through the facilities:
```{r graph_complete}
plot.mst = function(route){
  segments(x[route[,1]], y[route[,1]],x[route[,2]],y[route[,2]])
}
plot(x,y,pch=16)
plot.mst(route)
```









